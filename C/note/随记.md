[TOC]
#C_Tvt_随记

### `uintX_t` `intX_t` 相关

C99 加入，定义头文件`stdint.h`

__格式化输出:(`int8_t 为 char类型，当做字符处理`)__
```
uint16_t %hu
uint32_t %u
uint64_t %llu
```

__源码:__
```C 

typedef signed char             int8_t;   
typedef short int               int16_t;  
typedef int                     int32_t;  
# if __WORDSIZE == 64  
typedef long int                int64_t;  
# else  
__extension__  
typedef long long int           int64_t; 

typedef unsigned char           uint8_t;  
typedef unsigned short int      uint16_t;  
typedef unsigned int            uint32_t;  
#endif  
#if __WORDSIZE == 64  
typedef unsigned long int       uint64_t;  
#else  
__extension__  
typedef unsigned long long int  uint64_t;  
#endif  
 
```

---

### 函数实参形参问题

```C 
// 错误：(形参创建并销毁，对实参不产生影响)
void test( void* var_2){
    var_2 = (struct sample*) malloc (sizeof (struct sample));
    var_2->sample_int = 1;
    ...
}

int main (){
    struct sample* var_1 = NULL;
    test (var_1);
    // 运行到此处 var_1 == NULL
    return 0;
}

```

上述代码，执行`test (var_1)` 时，程序在动态内存中新申请 变量 `void* var_2`， 并指向NULL， `test()` 函数体内所有的操作均为对新变量 形参`void* var_2` 的操作。函数结束后，形参内存释放，开始时间形参`var_2`从`var_1`处获得了`NULL`的值后立马又指向`malloc`新开辟的内存空间,子函数全过程 var1没有参与，值一直是NULL。

解决方案一(__常用__): `var_1` 提前声明空间，然后用`memcpy` 内存操作函数在子函数中针对地址直接写入。

解决方案二(__不是很安全,多注意但可以用__): 传入参数类型改为 `void **`, 通过用形参传递指向 `var_1` 这个指针变量自身地址 的指针 来操作`var_1`。

---

### C/C++ 通用 内联函数 inline

##### 概念

在 C/C++ 中，__为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 `inline` 修饰符，表示为内联函数。__

如果一些函数被频繁的调用，不断地用函数入栈，即函数栈，则会造成栈空间或者栈内存的大量消耗。栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。

##### 使用限制

`inline` 的使用是有所限制的，__`inline`只适合涵数体内代码简单的涵数使用__，不能包含复杂的结构控制语句例如 `while、switch`，并且不能内联函数本身不能是直接递归函数。

`inline` 函数仅仅是一个对编译器的建议，所以最后能否真正内联，依据编译器判断。

__内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。__

##### 例子
```C    
void Foo(int v);
inline void Foo(int v) // inline 与函数定义体放在一起 {
    return (v % 2 > 0) ? "奇" : "偶";
}
```

##### 底层原理

对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。__在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。__这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。__假如内联函数是成员函数，对象的地址（this）会被放在合适的地方，这也是预处理器办不到的。__

与宏定义函数对比:

* 宏调用并不执行类型检查，甚至连正常参数也不检查，但是函数调用却要检查
* C语言的宏使用的是文本替换，可能导致无法预料的后果，因为需要重新计算参数和操作顺序。
* 对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。

---

### C标准库函数： 判断一个文件状态 access()

检查进程是否可以对指定的文件执行某种操作。

```C

#include <unistd.h>
#include <fcntl.h>
int access(const char *pathname, int mode);   
 
pathname: 需要测试的文件路径名。   
mode: 需要测试的操作模式，可能值是一个或多个R_OK(可读?), W_OK(可写?), X_OK(可执行?) 或 F_OK(文件存在?)组合体。 

//  是否存在

 if((access("sample.cfg",F_OK))!=-1)   
    {   
        printf("file sample.cfg exist.\n");   
    }   
    else  
    {   
        printf("file sample.cfg not exist\n");   
    }  

```

---
