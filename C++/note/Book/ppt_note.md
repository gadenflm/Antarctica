###课件汇总

1. __<  >  <=   >= 的优先级大于 ==   !=__

2. __静态存储(Static)：在文件运行期间有固定的存储空间，直到文件运行结束。__

   __动态存储：在程序运行期间根据需要分配存储空间，函数结束后立即释放空间。
         若一个函数在程序中被调用两次，则每次分配的单元有可能不同。__


3. __在C++中定义函数时，允许给参数指定一个缺省的值。__
   e.g. `int fac(int n=2)`


4. __new 相当于一个函数，在内存开辟完空间后，返回这个空间的首地址__
   e.g. `int* p = new int[SIZE];`

   __delete也可以收回用new开辟的连续的空间。__
   e.g. `delete []point;`


5. __引用(&)__: 引用是直接访问变量，不用分配自己的内存空间!!
   	用途主要是用来作函数的参数或函数的返回值。（与传递形参开辟新的内存空间，和传递指针即参数地址都不同）

   __引用&本质是所引用对象的地址，如果程序对引用做出改动，其实就是对目标的改动。__

```cpp
   	void swap (int &x, int &y){
   		int t;
    	t=x;
    	x=y; 
    	y=z;
	}
```


6. 如果未加说明，__类中成员默认的访问权限是private__
   
   成员函数的重载时，函数的形参必须在类型或数目上不同。

   构造函数是类的成员函数，系统约定构造函数名必须与类名相同。
   在定义构造函数时，不能指定函数返回值的类型，也不能指定为void类型。
   __一个类可以定义若干个构造函数。当定义多个构造函数时，必须满足重载的原则!__

   __析构函数是一个特殊的成员函数，函数名必须与类名相同，并在其前面加上字符“\~”__
   析构函数不能带有任何参数，不能有返回值，不指定函数类型!

 __当建立类ClassName的对象时，先调用各个对象成员的构造函数，初始化相应的对象成员，然后才执行类ClassName的构造函数，初始化类ClassName中的其它成员。析构函数的调用顺序与构造函数正好相反。__


7. 友元函数（类）
   
   __友元函数是一种定义在类外部的普通函数，其特点是能够访问类中私有成员和保护成员,即类的访问权限的限制对其不起作用!__

   __友元函数需要在类体内进行说明，在前面加上关键字friend。友元类同理__

   __友元函数破坏了类的封装性和隐蔽性，使得非成员函数可以访问类的私有成员__


8. 运算符重载

  __运算符重载就是赋予已有的运算符多重含义__。C++通过重新定义运算符，使它能够用于特定类的对象执行特定的功能

   运算符重载函数，通常是类的成员函数或者是友元函数。运算符的操作数通常也应该是类的对象。

   __operator是定义运算符重载函数的关键字，它与其后的运算符一起构成函数名！__
  ` <类名>  operator<运算符> (<参数表>)   {  函数体}`

   e.g. `friend A operator+ (A &b){};`


   ++为前置运算时，它的运算符重载函数的一般格式为： <类名> operator ++( )
   ++为后置运算时，它的运算符重载函数的一般格式为： <类名> operator ++(int)	


   运算符的重载函数定义为友元函数，参与运算的对象全部成为函数参数。
   e.g. `friend  A  operator+ (A &a, A &b){};`
   
   __单目运算符(只有一个操作数的运算符)最好被重载为成员函数；对双目运算符最好被重载为友元函数。__

   转换函数就是在类中定义一个成员函数，其作用是将类转换为某种数据类型。
   格式为: `ClassName::operator <DataType>(){}`

   e.g. `A::operator float () { return...; }`


9. 当从已有的类中派生出新的类时，可以对派生类做以下几种变化：

- __可以继承基类的成员数据或成员函数。__
- __可以增加新的成员数据。__
- __可以增加新的成员函数。__
- __可以重新定义已有的成员函数。__
- __可以改变现有的成员可见性。__
   在C++中有二种继承：单一继承和多重继承。当一个派生类仅由一个基类派生时，称为单一继承；
   而当一个派生类由二个或更多个基类所派生时，称为多重继承。


<font color=red >
__基类__

* public: 在派生类和类外可以使用
* protected: 在派生类中使用
* private: 不能在派生类中使用

</font> 

   任一基类在派生类中只能继承一次，否则，会造成成员名的冲突。
   若在派生类中，确实要有两个以上基类的成员，则可用基类的两个对象作为派生类的成员。

   可以将派生类对象的值赋给基类对象。反之不行！


10. 可以在程序运行时通过调用相同的函数名而实现不同功能的函数称为虚函数。

__虚函数是用关键字virtual修饰的某基类中的protected或public成员函数。__
	
__只有在程序的执行过程中，依据指针具体指向哪个类对象，或依据引用哪个类对象，才能确定激活哪一个版本，实现动态聚束。__

__一旦把基类的成员函数定义为虚函数，由基类所派生出来的所有派生类中，该函数均保持虚函数的特性。__

__在派生类中重新定义基类中的虚函数时，可以不用关键字virtual来修饰这个成员函数 。__

__虚函数必须是类的一个成员函数，不能是友元函数，也不能是静态的成员函数。__

__实现这种动态的多态性时，必须使用基类类型的指针变量，并使该指针指向不同的派生类对象
并通过调用指针所指向的虚函数才能实现动态的多态性！！！！__


11. 静态成员：<font color=red >__不管这个类创建了多少个对象，静态成员在内存中只保留一份，静态成员用来解决同一个类中不同对象之间数据成员和函数的共享问题。__</font>

	

	__类的静态成员(变量和方法)属于类本身，在类加载的时候就会分配内存，可以通过类名直接去访问；__

	__非静态成员（变量和方法）属于类的对象，所以只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。__