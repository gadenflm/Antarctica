[TOC]
# C++ Primer 笔记

## Chapter 1

### 面向对象 和 面向过程

将计算机程序理解成 算法 + 数据。

C 面向过程编程 可以理解成更强调程序算法(过程)方面，__使用结构化编程，思考方式自顶向下：将大型程序需要解决的任务分解成小型的，易于编写的模块。__

C++ 面向对象编程 可以理解成更强调程序的数据，__理念上追求设计出与任务本质特性相对应的数据格式，即对象。 面向对象的思考出发点首先是设计对象(class), 让类可以准确表示程序要处理的东西。__ 最后逐步设计一个使用这些类的程序。  __思考方式为自下向上。__

### 泛型编程

面向对象编程强调的是数据方面，__泛型编程则是想独立于特定数据类型，使得一个泛型函数可以用于各种数据类型，C++ 模板(template)提供这一机制__

## Chapter 2 ~ 3 基础

### 随记

```CPP
cout << "Hello World!"
	 << endl;
```
`cout` 为 `iostream` 头文件中定义的`ostream`类(class)的对象. 其重载运算符 `<<`, 从而将 `<<` 右侧信息插入到输出流中. 
`endl` 为 `iostream` 头文件中定义的控制符(manipulator), 位于名称空间(namespaces) `std` 中.

---

```CPP
int a,b,c;
a = b = c = 726;
```
同C, 赋值从右向左进行 并 可以连续赋值。

---

```CPP 
int var{7};   		// set var to 7
int array[26] = {};	// set all elements of array to 0
int array[26]{};
```
C++ 使用大括号给变量赋予初始化值时可以省略等号, 同时可以省略大括号里的内容(此时初始化为0).

---

```CPP
std::cout << std::hex;
cout << "Hex Num: 0x" << 0x42 << endl;
```
对cout对象的输入控制符`std::hex`, 并不会输出任何内容, 而是修改`cout`显示整数的方式

同理有 `std:dec` `std:oct` `std:hex`. 因此`using namespace std;` 后, 不能使用变量名`hex` `oct` `dec`.

---

```CPP 	
cout << A;	  		// show 65 in console;
cout.put('A');		// show A in console;
```
cout 默认输出char类型会输出其整数值即ASCII码. 单独输出字符可使用 ostream 类的成员函数 `put()`

---

__bool 类型的字节大小为 1, 任何数值类型的量都可以被隐式转换为 bool 类型.__

### C++ 常量(字面量)类型确定

* 整形常量默认类型为int, 仅当太大或者有特殊后缀时会理解为其他类型。
* 后缀:
	- `l L` 表示该整数为 long 类型常量
	- `u U` 表示该整数为 unsigned 类型常量

* 浮点常量默认类型为 double, 改为 float 或 long double 则需要使用后缀 `f F` `l L`

举例 :
```CPP 
//  unsigned long long int:
uint64_t var = 19970726ULL;
```

### 通用字符名(多字节字符)

针对独立于键盘的其他字符,C++引入特殊字符机制。对应ISO 10646 码点, 其通过转义符 `\u` 代表2字节字符 `\U` 代表4字节字符。 

``` CPP 
int k\u00F6rper; 							// C++存储变量名为 uǎrper
cout << "Let's eat g\u00E2teau\n";			// will show "Let's eat güteau"
```
如注释, `\u`后的四个16进制数会被解析成对应字符, 并用于c++ 存储或输出中

__ISO10646 正常情况下对应于 Unicode编码__

__C++11新增变量类型 `char16_t` 对应 `\u` `\U` 的双字节和四字节字符, 举例如下__
```CPP
char16_t ch1 = u'q';
char32_t ch2 = U'\U0000222A';
```
### 隐式类型转换相关

1. C++ 允许将一种类型的值赋给另一种类型的变量, 值将被转为接收的类型

* 长浮点类型(double) 转为 浮点(float), 若超出范围会导致结果不确定
* 浮点(float) 转为 整型, 若超出范围会导致结果不确定
* 长整型(long) 转为 整型(int), 只复制右边的字节 

__使用大括号`{}`进行变量初始化, 会保证左值右值的字节数一样. 可用于避免许多隐式类型转换__

```CPP
char ch = {65};
```
2. C++ 计算表达式中 存在自动类型转换.

* __int 为计算机默认计算最自然的类型, 所有小于 int 字节数的 整型 字符类型等等都会被转换为 int/ unsigned int 参与运算, 这一过程称为 整型提升(integral promotion)__
* C++ 11 的校验表
	- (1) 双目运算 存在类型 long double, 另一个数 自动转为 long double
	- 否则(2) 双目运算 存在类型 double, 另一个数 自动转为 double
	- 否则(3) 双目运算 存在类型 float, 另一个数 自动转为 float
	- 否则(4) 双目运算 两侧全为 整型, 整型提升
	- ...(有无符号位类型转换)

3. 传递参数时, __类型转换通常由 c++ 函数原型控制.__ 若取消原型对参数的控制, 则 C++ 会引入整型提升, 同时将 float 转为 double 传入.

### 强制类型转换
```CPP 
// C type:
a = (int) var;
// Cpp type:
a = int (var);
```
上面两种格式都可以，分别对应 C 和 C++ 标准中的转换形式。


## Chapter 4 数组、字符串、结构、指针、动态类型

### 随记

__数组被称为复合类型是由于基于其他已有类型才能创建__

---

```CPP 
char a[] = "Hello World!";
cout << "Hello" " World!" << endl;
```
双引号内称为字符串常量或者 __字符串字面量__, 其隐式包含结尾的`\0`, 且 __实际赋值时，字符串字面量为其字符串所在内存的开始地址.__

由空白(空格、换行、制表符)分隔的字符串字面量将被编译器自动拼接。

---

### 数组初始化

```CPP 
int a[100] = {0};                  		// 每一个元素都被设置成0
int a[100] = {1997,7,26};          		// 除前三个元素为 1997,7,26, 其余均为0
int a[] = {1997,7,26};					// 只开辟三个int型连续内存空间，分别存放1997,7,26.

// C++11:
double a[3] {1.2e4, 3.14, 1.8e-6};		// C++ 11 后可省略 等号
```
只有再申明时才能使用上述初始化方法。 只对一部分元素初始化，则编译器会自动将其余部分置为0.

### C-style 字符串

```CPP
char str[] = {'H','e','l','l','o','\0'};   	// 字符串
char array_char[] = {'H','e','l','l','o'};  // 字符数组，不是字符串!!
```
__C 风格字符串有特殊性质：以空字符(`\0`)结尾，其ASCII码为0.__

### C++ cin 对象成员函数 get/getline
```CPP
// getline() sample:
{
	const int ArSize = 20;
	char name[ArSize];
	cin.getline (name,ArSize);
}

// get() sample:
{
	const int ArSize = 20;
	char FirstName[ArSize];
	char LastName[ArSize];
	cin.get(FirstName,ArSize);
	cin.get();  // cin.get() 默认不读取换行符，因此需要再读取一个。同时此处涉及函数重载，cin对象的成员函数根据参数的不同分别调用读取字符串和读取字符两个不同的函数。
	// 这种方法也可以： cin.get(FirstName,ArSize).get()
	cin.get(LastName,ArSize);
}
```
get 和 getline 与 cin 不同。 cin读取时遇到 空白(空格、换行、制表符) 即判定读取结束，而`get` 和 `getline` 仅识别换行符作为结束，`getline` 丢弃换行符，而 `get` 不丢弃。

### C++ string class
``` CPP
std::string std_str;  // string 类位于 名称空间 std 中。

using namespace std;
string str1 = "Hello World";
string str2;
cin >> str2; //  自动处理 string 的大小,程序会自动调整长度。
cout << str1[0] << endl; 

string str3 = str1 + str1;  // 重载了运算符，可以简单相加来实现 字符串连接
str3 += str1;
```

* __string 类位于 名称空间 std 中__
* __可使用数组表示法来访问string对象中的字符__
* __string 的变量是一个对象__ 
* __与数组不同，可以将一个string对象赋给另一个string对象__
* __重载了运算符，可以简单相加来实现 字符串连接__
* __string 类可以理解成一种动态数组__

---

``` CPP 
int len1 = str1.size();
int len2 = strlen(str1);
```
两种方法都可以获得长度

---

``` CPP 
getline(cin, str1); 
```
string 对象想要读取一行，不能使用 cin 的成员函数 `getline()` ，而使用 istream 引入的函数 `getline()`, `getline(cin, str1);`会指代该函数以 `cin` 作为输入流读取 str1;

### 结构 struct
```CPP 
struct st_var
{
	int key;
	std::string value; // 注意名称空间
};

// C++ 申明结构变量时可以省略 struct
st_var kv_1;
struct st_var kv_1;
```
* __C++ 申明结构变量时可以省略 struct, 而C 不会__
* __其初始化方式等与C基本相同__
* __同类型的结构间可以使用赋值符号来实现拷贝变量内存空间中的值__
* __C++ 中，结构体可以包含成员函数！！！！！__

### 共用体 union / 枚举 enum
```CPP 
enum var 
{
	zero, null = 0,              // zero, null 都为0
	one, first =1				 // one, first 都为1
};
```
union 与 C 基本一样，常用为 __匿名共用体或者匿名结构直接互相嵌套__
enum 与 C 基本一样， 默认首元素为0。 __C++ 中可以创建多个值相同的枚举量!__

### 指针

__OOP(面向对象) 中提倡在运行阶段进行决策而不是编译阶段。e.g. 运行阶段确定数组的长度： 使用关键字new 请求正确数量的内存并使用指针定位__
__指针与数组的结合及运算关系与C一样，较复杂，可看 C-Primer 笔记__

```CPP 
int *p1, p2;					// p1 为指向int的指针类型， p2 为int 类型
int *p1, *p2;					// p1 p2 都为指针类型

p1 = 0x80000000; 				// C++ 中错误！！！
p1 = (int*)0x80000000;			// 正确方式

// 顺序简单记录，详细看 C-primer
short (*p)[20]; 				// 由于括号，* 运算符先作用于 符号p, 表明 p 是一个指针，然后继续，该指针指向一个存放 20 个short的数组。 p++ 将直接将地址加20个字节！
short *p[20];					// [] 优先级高于 *,  [20] 作用于 符号p, 表明 p 是含有20个元素的数组，该数组存放的是short * 类型的指针变量，此时连续开辟20个指针变量！
```
与 C 一样， __使用 指针指向的空间前，一定要确保指针指向某个合理的地址！！！！__

``` CPP
// 如下代码严重错误！！！！！！！！！！！！！！！！！！！！
int * p1;						// p1 没有指向任何内存空间
*p1 = 233333;
```

### new
```CPP 
int *p1 = new int;
delete p1;  					// 该语句只会释放new 分配的对应空间，并不会删除指针本身！ 可以重新指向其他内存块！
```
<font color="red" size="4">
通用格式如下:
typeName * pointer_name = new typeName;

__常规局部变量存储在 栈区(stack).__
__而new 从堆(heap) 或 自由存储区(free store) 的内存区中 分配内存.__
</font>

#### 使用new 创建动态数组

__在运行阶段如果需要数组则创建；否则不创建。且运行时再选择数组的长度，这被称为动态联编(dynamic binding)，数组被称为动态数组(dynamic array)__

```CPP 
int * psome = new int [n];       // 主要格式！！！
delete [] psome;
```

#### delete

delete 会释放new 分配的对应空间，并不会删除指针本身！ 指针可以重新指向其他内存块！
理论上，只能用delete释放使用new分配的内存，但 空指针参数对于delete 也是安全的;

* __delete 只能释放 new分配的内存__
* __delete 释放同一个内存块两次，将导致不确定结果！__
* __`[]` 对于new 和 delete 需要严格对应出现__

```CPP
//合法， 但不推荐！！
int * p1 = new int;
int * p2 = p1;
delete p2;
```
<font color="red">
一般来说，不创建两个指向同一个堆(heap) 或 自由存储区(free store) 内存块的指针，这将增加删除同一个内存块两次的可能性。
</font> 

### 内存相关--基础

C++ 有3种管理内存的方法, 自动存储, 动态存储, 静态存储.

1. 自动存储
局部变量, 作用域对应代码块, __通常情况下, 自动存储为栈内存中, 执行代码块时, 其中的变量依次加入到栈中, 离开代码块时, 将按相反顺序释放这些变量。栈中占用的内存大多数情况下都时连续的__

2. 动态存储 
动态存储管理一个内存池, 在C++ 中被称为 自由存储空间 或 堆(heap)。 其数据完全不受程序运行状态的控制, 需要程序员自己进行内存管理, __堆内存中, 申请的空间并不连续！__

3. 静态存储
静态存储在整个程序执行期间都存在。

### STL 模板类 vector
<font color="red" size="4">

* vector 类包含在 名称空间 std 中
* vector 类使用 `new / delete` 管理内存, 但管理内存工作是自动完成的, 可以很好的作为`new` 创建动态数组的替代品
* `vector<typeName> VarName(Num)`
* 对应头文件 `#include <vector>`
* 可使用标准数组表示法访问各个元素! `a[0]`
* 标准数组表示法不检查越界, 可用成员函数`at()` `begin()` `end()` 等访问, 对应效率会下降. `v.at(2) = 1.2;`

</font>

```CPP 
#include <vector>
std::vector<int> v_0; 	// 创建一个 0长度的 vector
int n = 10;
std::vector<int> v(n); 	// 创建一个 10 长度的vector
v[0] = 1; 				// 效率更高，但不安全
v.at(1) = 2;			// 会检查越界等，但效率下降

```
### STL 模板类 array (C++11)
__STL array 类 为 C++11 引入, 与vector 不同, array 类使用 静态内存分配, 数据位于 栈内存中. 效率高于 vector.__
```CPP
#include <array>
std::array<int, 10> a;
std::array<double, 4> b = {1.1, 1.2, 3.14, 4.86};
```

## `Chapter 5~6` 循环, 分支, 逻辑

### 随记
<font color="red" size="4">
建议使用 value == variable 替代 variable == value, 让漏写等号时程序可以报错
</font>

```CPP
if (3.14 == pi)
	cout << "It's Pi" << endl;
```

---

### 递增递减运算符
#### 副作用与顺序点

```CPP 
// 避免下面这种写法！！！！！
y = (4 + x++) + (5 + x++); // C++ 只保证 该语句结束后(顺序点后)， x+=2, 过程中 x 是否变化并不确定！！！
```
副作用指的计算表达式值时, 进行的修改（如存储的值）
__顺序点为 C++11 前的术语, 在每个顺序点进行下一步之前, 会确保所有副作用都已经完成。 上式中 `;` 就是一个顺序点__
__C++ 只保证 递增递减运算符(`++``--`) 在顺序点前后正确, 过程中并不保证！__

#### 优先级
__前缀递增 前缀递减运算符(`++p``--p`) 与 解引用运算符(`*`) 优先级相同, 后缀递增 后缀递减 (`p++` `p--`) 优先级更高__

```CPP 
*++p 					// 从右向左结合, ++ 先运算，指针前进对应大小的1个内存块,  然后解引用取得值
++*p 					// 先解引用取得当前p 的值, 然后 加1 作为表达式返回值
(*p)++					// 先解引用取得当前p 的值, 然后 加1 作为表达式返回值
*p++					// ++ 先运算，但是是后缀，所以表达式返回值为解引用取得值，然后指针前进对应大小的1个内存块,  

```

### 逗号运算符

针对表达式(expression), C++ 允许使用 `,` 运算符 并列多个表达式, 逗号是一个顺序点, 确保并列的表达式从左往右依次产生副作用, 但整体表达式返回最后一个运算的值。
__变量申明中的`,` 并不是逗号运算符, 与分隔表达式完全不同__
__逗号运算符的优先级是所有运算符中最低的__

```CPP 
int a;
a = 1,2; // a 为1, 因为 逗号运算符 优先级低于 赋值运算符, 所以语句被解释成 (a = 1), 2;
a = (1,2); // a 为2
```

### 字符串比较
字典排序: 若两字符串不等, 依次从前往后寻找到第一个对应不相等的字符, 按ASCII 码顺序比较大小, 小的在前,大的在后

#### C-style  strcmp()
```CPP 
strcmp(str1, str2);
```
* 两字符串相等, 返回0; 
* str1 字典排序 在 str2 之前,  返回负数;
* str1 字典排序 在 str2 之后,  返回正数数;

#### string 类
__string 类重载了关系运算符, 可以直接比较。__

### range-based for (C++11)

__主要用于数组或模板类，例如 STL.若要修改数组中的元素, 需要使用引用变量__

```CPP
// 仅访问数组的元素
double arr_var[] = {1.2,2.3,3.14,4.5};
for (double x: arr_var)
{
	cout << x << endl;
}

//修改数组中的元素, 需要使用引用变量
for (double &x: arr_var)
{
	++x;
}

// 也可以使用这种写法
for (int x : {3, 1, 4, 1, 5, 9, 2, 6})
{
	cout << x << endl;
}

```

### C++ Input 基础

#### cin

* 默认情况下, cin类 重载`>>` 作为输入时会 跳过一切空白(空格、换行、制表符)
* 默认情况下, cin类 重载`>>` 作为输入时会 将输入先送入缓冲区, 即用户按下回车键后输入才会被发送给程序
* `cin.get(ch)` 不会跳过空白
* __`cin.get()` 参数变量为引用类型, 因此不需要将地址传入, 直接传入原变量就能修改其值。__

#### 文件尾(EOF)和重定向

* 同C, 文件尾为预先定义的宏`EOF`, (End of File)
* 重定向过程与机制与C 基本一样, 重定向会修改程序对 `EOF` 的解释。
* __检测到EOF后, cin 会将两个标志位(eofbit, failbit)设置为1. 其对应检测方法为 cin 两个成员函数__
	- `cin.eof()` 在`eofbit == 1`下返回 true, 否则返回 false
	- `cin.fail()` 在`eofbit == 1 && failbit == 1`下返回 true, 否则返回 false
	
```CPP 
char ch;
cin.get(ch);
while(!cin.fail())
{
	cout << ch;
	cin.get(ch);
}
```
### 逻辑运算符

* `||` 是个顺序点, `||` 会先使左侧式子的副作用生效, 再对右侧的表达式进行判定
* __`||` 如果左侧的表达式为true, C++ 将不会判定右侧的表达式(举例,可以用来处理 除数为0的判定)。__
* __`||` 与 `&&` 的优先级均比 关系运算符(`>` `<` `==` ...) 低, 不用加括号__
* __`!`  优先级均比 关系运算符(`>` `<` `==` ...) 高, 必须加括号__

## `Chapter 7~8` 函数

### 函数 传递参数/返回值 的底层过程

__通常, 被调用函数 将 返回值复制到指定的 CPU寄存器 或 内存单元 中来将其返回。随后, 程序的 原函数 将查看该内存单元。 即 传递参数/返回值 都会发生内存的 拷贝过程。__

__因此 被调用函数 和 原函数 必须就该内存单元中存储的数据类型达成一致。 具体如下： 原函数获得的返回类型来源于 函数原型(function prototype),  被调用函数的 返回类型 来源于 函数定义(function definition)__

__进一步, 函数原型(function prototype) 描述的是函数到编译器的接口, 将 函数返回值的类型 以及 参数的类型 和 参数的数量 告诉编译器。 编译器因此将知道去对应内存或寄存器中 检索多少个字节__

```CPP
double sqr(double x); 					//函数原型(function prototype)
int main ()
{
	double x = 2.5;
	std::cout << sqr(x) << std::endl;  	//此处获得返回类型为 double 来源于 函数原型
}

double sqr(double x) 					//函数定义(function definition)
{
	return x*x; 						//此数获得返回类型为 double 来源于 函数定义 
}
```

自动类型转换：__若调用函数时, 参数类型与 函数原型 不对应, 编译器 将尽可能 把传入的参数 转成 正确类型__

### 函数参数 为数组

```CPP 
int sum_arr(int arr[], int n)         // 传递数组时指定数组名, 本质为传递首元素指针, 但实际与直接传递指针有区别！！！！！！
{
	int ret;
	for (i = 0; i < n; ++i)
		ret += i;
	return ret;
}
```
参数数组时为可用`int arr[]`指定数组名, 本质为传递首元素指针, 但实际与直接传递指针有一些区别:

*  此时, 对数组名使用 `sizeof` 将得到整个数组的长度(单位:字节)
*  此时, `&` 取地址运算符 将返回 整个数组的首地址, 而不是其首元素的地址, 这两个过程值虽然一样, 整个数组的首地址指代一个更大的内存块。

#### 二维数组

```CPP
void test_func(int (*ar)[2], int size);  // ar 为指向 int[2] 类型的 指针变量。 size 对应有几个 int[2]
void test_func2(int ar[][2], int size);  // 也可以写成这种形式
int main()
{
	int data[3][2] = {{1,2},{3,4},{5,6}};
	test_func(data,3);
	test_func2(data,3);
}
```
注意格式为 `int(*ar)[2]`, 因为`()` `[]` 的优先级均比 `*` 高， 因此不能省略 `()`

### 指针与const

* 情况一:
```CPP
const int age = 24;
const int * pa_1 = &age;
```
此时，pa_1 为指向 const int 类型的指针变量。 age 也为 const int 类型常量。 __pa_1 可以指向其他 const int 或者 int 类型，只是从 pa_1 角度出发，因为指向的是const int类型， 所以不能修改指向空间内的值。__

* 情况二：
```CPP
int age = 24;
const int * pa_2 = &age; 
```
此时, 指向 const int 类型的指针变量。 __但 age 是 int类型变量, 从 pa_2 角度出发，不能修改指向空间内的值。 但 age 本身的值可以被修改！__

* 情况三:
```CPP
// 错误！！！！！！！！！！！！！！！！！
const int age = 24;
int* pa_wrong = &age;
```
<font color="red">此时，编译错误</font>  
__C++ 中, 非const 指针， 只能指向非 const 类型的数据__

* 情况四:
```CPP 
int age = 24;
int * const pa_4 = &age;
```
此时， pa_4 为 指向 int 类型的指针变量, 但 pa_4 本身有 const 申明， __因此不能修改 pa_4 指向的空间地址, 但可以通过该地址修改内部的值。__

* 情况五:
```CPP 
int age = 24;
const int* const pa_5 = age;
```
此时, pa_5 为指向 const int 类型的指针变量, 同时本身也有 const 申明， __因此 既不能修改 pa_5 指向的空间地址，也不能通过该地址修改内部的值__

### 函数指针

__函数也有地址, 函数的地址是存储其机器语言代码的内存的开始地址__

```CPP
void test_func(void* param);
void run(void (*pfunc) (void*), void* par)
{
	(*pfunc)(par);
}
```
`void (*pfunc) (void*)` 申明了一个 指针变量 pfunc,  指向 返回类型为 `void` ,参数为一个，参数类型为 `void*` 的函数。

__C++中, 可用 auto 自动生成 指向函数的指针, 同时也可以用 typedef 专门定义指向某种函数的指针变量 的类型符号， 此处不展开。__

### 内联函数(可执行程序原理)

```CPP
inline double square(double x)
{
	return x*x;
}
```
<font color="red" size="4">

可执行程序由机器语言指令组成，操作系统将机器语言指令载入到内存中，每条指令都有特定的内存地址，顺序执行时，计算机逐步执行这些指令，有时会向后或向前跳到特定地址。（循环或分支等等）。  

常规函数调用（按如下顺序）：  
1. 程序执行到函数调用指令，存储该调用指令的内存地址。  
2. 将函数参数复制到堆栈(针对性保留的内存块)。  
3. 跳到标记函数起点的内存单元，执行函数代码。  
4. (如有返回值，复制返回值到寄存器中)  
5. 跳回地址被保存的调用指令处  
__来回跳跃并记录内存位置使得常规函数调用增加开销。__

__内联函数：编译器在编译时 使用相应的函数代码 直接替换函数调用(注意在编译阶段而不是 预处理阶段！)。 因此对于内联代码，程序无需跳到另一个内存位置处执行代码，再跳回来，比常规函数稍快，但代价需要占用更多的内存。__

</font>

#### 概念

在 C/C++ 中，__为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 `inline` 修饰符，表示为内联函数。__

如果一些函数被频繁的调用，不断地用函数入栈，即函数栈，则会造成栈空间或者栈内存的大量消耗。栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。

#### 使用限制

`inline` 的使用是有所限制的，__`inline`只适合涵数体内代码简单的涵数使用__，不能包含复杂的结构控制语句例如 `while、switch`，并且不能内联函数本身不能是直接递归函数。

`inline` 函数仅仅是一个对编译器的建议，所以最后能否真正内联，依据编译器判断。

__内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。__

#### 底层原理

对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。__在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。__这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。__假如内联函数是成员函数，对象的地址（this）会被放在合适的地方，这也是预处理器办不到的。__

与宏定义函数对比:

* 宏调用并不执行类型检查，甚至连正常参数也不检查，但是函数调用却要检查
* C语言的宏使用的是文本替换，可能导致无法预料的后果，因为需要重新计算参数和操作顺序。
* 对于基于C的编译系统，内联函数的使用可能大大增加编译时间，因为每个调用该函数的地方都需要替换成函数体，代码量的增加也同时带来了潜在的编译时间的增加。

### 引用变量(左值引用&)

```C++
int rats;
int& rodents = rats;
```
__`&` 是类型标识符的一部分， `int &` 指的是 int 的引用。 上述类型申明使得 rats 和 rodents 指向相同的值和内存单元。__

__引用必须在申明引用时将其初始化。不能先申明再赋值！！！！__

引用用作函数参数，使得函数中的变量名成为调用程序中变量的别名。

#### const 修饰左值引用

```C++
struct data
{
	int				key;
	std::string 	value;
};

void display(const data& STData)
{
	cout << STData.key << ':' << STData. value << endl;
}

data& add(data& target,const data& source)
{
	target.key += source.key;
	return target;
}
```

__const 修饰可以避免无意中修改数据，同时函数能够处理const 和 非const 实参， 否则将只能接受 非const 数据！！因此使用引用传参时 应该尽可能的使用 const 左值引用。__

__对于 结构体、 类而言， 使用引用传递参数 比 按值传递(拷贝原始结构) 更节省时间和内存！！ 同理对于返回值也是这个道理，当返回值为 结构、类时，使用引用可以提升效率，但要注意返回 函数内部 局部变量的引用没有任何意义！！__

如果函数的形参为const 修饰的左值引用，编译器将在如下情况生成临时变量：
* 实参的类型正确，但不是左值，如`func(7.0)``func(a + 7)`
* 实参的类型不正确，但可以转换为正确的类型

#### 对象、继承和引用

__基类引用可以指向派生类对象！(该过程无强制类型转换), 实际而言，可以定义一个接受基类引用作为参数的函数，调用函数时，基类对象和派生类对象均可以作为实参。__

### 函数的默认参数

```C++
// 默认参数在函数原型中申明
char left( const char* str, int n = 1);
char left( const char* str, int n)
{
	return str[n];
}
```
通过函数原型，使得调用时省略实参自动使用默认值。__对于带参数列表的函数，必须从右向左添加默认值，也就是说，要为某个参数设置默认值，需要为它右边的所有参数提供默认值！__

### 函数重载(多态)
```C++
int left (int num, int n)
{
	return num - n;
}

char left(const char* str, int n)
{
	return str[n];
}

```
__函数重载的关键是参数列表,也成为函数特征标(function signature). 如果两个函数的参数数目和类型和排列顺序相同，则它们的特征标相同(与变量名无关)__  
__C++ 允许定义函数名 相同的函数，条件是他们的特征标不同。__  
__编译器在检查函数特征标时，把类型引用和类型本身视为同一个特征标！__  
__C++函数重载只能是特征标不同，  特征标相同，函数返回类型不同的两个函数会直接报错！__

### 函数模板(template!)
```C++
template <typename T> // 关键字为 template 和 typename， C98 前 typename 也可以用 class 代替
void Swap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}
int main()
{
	int i = 1, j = 2;
	Swap(i,j); // 编译器编译该句时，为Swap 生成一个 Swap(int&, int&) 的实例！（隐式实例化）
}
```
__一般将模板放在头文件中！__  
<font color="red">   

模板原理（隐式实例化）：__编译器在调用函数时，根据类型 自动生成 函数实例 编译成 可执行程序！！因此函数模板不能缩短可执行程序，最终编译后的程序不包含任何模板，只包含为了程序生成的实际函数！__	
</font>

#### 显示实例化
```C++
template <typename T> 
void Swap(T& a, T& b)
{
	T temp = a;
	a = b;
	b = temp;
}
int main()
{
	template void Swap<char>(char &, char &); // 显示实例化语法，编译器执行此句话时，将根据现有模板函数 Swap 立马生成一个 Swap(char &,char &) 的实例!!
	int i = 1, j = 2;
	Swap(i,j); // 编译器编译该句时，为Swap 生成一个 Swap(int, int) 的实例！（隐式实例化）
	char a = '1', b = '2';
	Swap(a,b); // 编译器直接调用 生成好的 Swap(char &, char &)实例
}
```
显示实例化实际需要使用的情况很少！注意在 函数体中调用 而不是 申明，需要与 显示具体化区分！  

已知显示实例化作用：  
* 显式实例化能提高编译效率
* 显式实例化放到一个文件中让其他文件包含，使用时只要实例化一次，减少了重复实例化次数。(个人理解：每个Cpp 编译时都会生成一个 obj 文件, 假如头文件中有一个 模板函数，大量不同的 cpp 文件调用该函数，每个cpp 编译时生成的obj 文件中都包含 对该函数对应实例，出现大量冗余！)
* 使用显式实例化，可以将实现放在cpp文件中，而不必放在头文件中。 对外隐藏实现!!

#### 显式具体化!!






