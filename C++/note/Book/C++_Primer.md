[TOC]
# C++ Primer 笔记

## Chapter 1

### 面向对象 和 面向过程

将计算机程序理解成 算法 + 数据。

C 面向过程编程 可以理解成更强调程序算法(过程)方面，__使用结构化编程，思考方式自顶向下：将大型程序需要解决的任务分解成小型的，易于编写的模块。__

C++ 面向对象编程 可以理解成更强调程序的数据，__理念上追求设计出与任务本质特性相对应的数据格式，即对象。 面向对象的思考出发点首先是设计对象(class), 让类可以准确表示程序要处理的东西。__ 最后逐步设计一个使用这些类的程序。  __思考方式为自下向上。__

### 泛型编程

面向对象编程强调的是数据方面，__泛型编程则是想独立于特定数据类型，使得一个泛型函数可以用于各种数据类型，C++ 模板(template)提供这一机制__

## Chapter 2 ~ 3 基础

### 随记

```CPP
cout << "Hello World!"
	 << endl;
```
`cout` 为 `iostream` 头文件中定义的`ostream`类(class)的对象. 其重载运算符 `<<`, 从而将 `<<` 右侧信息插入到输出流中. 
`endl` 为 `iostream` 头文件中定义的控制符(manipulator), 位于名称空间(namespaces) `std` 中.

---

```CPP
int a,b,c;
a = b = c = 726;
```
同C, 赋值从右向左进行 并 可以连续赋值。

---

```CPP 
int var{7};   		// set var to 7
int array[26] = {};	// set all elements of array to 0
int array[26]{};
```
C++ 使用大括号给变量赋予初始化值时可以省略等号, 同时可以省略大括号里的内容(此时初始化为0).

---

```CPP
std::cout << std::hex;
cout << "Hex Num: 0x" << 0x42 << endl;
```
对cout对象的输入控制符`std::hex`, 并不会输出任何内容, 而是修改`cout`显示整数的方式

同理有 `std:dec` `std:oct` `std:hex`. 因此`using namespace std;` 后, 不能使用变量名`hex` `oct` `dec`.

---

```CPP 	
cout << A;	  		// show 65 in console;
cout.put('A');		// show A in console;
```
cout 默认输出char类型会输出其整数值即ASCII码. 单独输出字符可使用 ostream 类的成员函数 `put()`

---

__bool 类型的字节大小为 1, 任何数值类型的量都可以被隐式转换为 bool 类型.__

### C++ 常量(字面量)类型确定

* 整形常量默认类型为int, 仅当太大或者有特殊后缀时会理解为其他类型。
* 后缀:
	- `l L` 表示该整数为 long 类型常量
	- `u U` 表示该整数为 unsigned 类型常量

* 浮点常量默认类型为 double, 改为 float 或 long double 则需要使用后缀 `f F` `l L`

举例 :
```CPP 
//  unsigned long long int:
uint64_t var = 19970726ULL;
```

### 通用字符名(多字节字符)

针对独立于键盘的其他字符,C++引入特殊字符机制。对应ISO 10646 码点, 其通过转义符 `\u` 代表2字节字符 `\U` 代表4字节字符。 

``` CPP 
int k\u00F6rper; 							// C++存储变量名为 uǎrper
cout << "Let's eat g\u00E2teau\n";			// will show "Let's eat güteau"
```
如注释, `\u`后的四个16进制数会被解析成对应字符, 并用于c++ 存储或输出中

__ISO10646 正常情况下对应于 Unicode编码__

__C++11新增变量类型 `char16_t` 对应 `\u` `\U` 的双字节和四字节字符, 举例如下__
```CPP
char16_t ch1 = u'q';
char32_t ch2 = U'\U0000222A';
```
### 隐式类型转换相关

1. C++ 允许将一种类型的值赋给另一种类型的变量, 值将被转为接收的类型

* 长浮点类型(double) 转为 浮点(float), 若超出范围会导致结果不确定
* 浮点(float) 转为 整型, 若超出范围会导致结果不确定
* 长整型(long) 转为 整型(int), 只复制右边的字节 

__使用大括号`{}`进行变量初始化, 会保证左值右值的字节数一样. 可用于避免许多隐式类型转换__

```CPP
char ch = {65};
```
2. C++ 计算表达式中 存在自动类型转换.

* __int 为计算机默认计算最自然的类型, 所有小于 int 字节数的 整型 字符类型等等都会被转换为 int/ unsigned int 参与运算, 这一过程称为 整型提升(integral promotion)__
* C++ 11 的校验表
	- (1) 双目运算 存在类型 long double, 另一个数 自动转为 long double
	- 否则(2) 双目运算 存在类型 double, 另一个数 自动转为 double
	- 否则(3) 双目运算 存在类型 float, 另一个数 自动转为 float
	- 否则(4) 双目运算 两侧全为 整型, 整型提升
	- ...(有无符号位类型转换)

3. 传递参数时, __类型转换通常由 c++ 函数原型控制.__ 若取消原型对参数的控制, 则 C++ 会引入整型提升, 同时将 float 转为 double 传入.

### 强制类型转换
```CPP 
// C type:
a = (int) var;
// Cpp type:
a = int (var);
```
上面两种格式都可以，分别对应 C 和 C++ 标准中的转换形式。


## Chapter 4 数组、字符串、结构、指针、动态类型

### 随记

__数组被称为复合类型是由于基于其他已有类型才能创建__

---

```CPP 
char a[] = "Hello World!";
cout << "Hello" " World!" << endl;
```
双引号内称为字符串常量或者 __字符串字面量__, 其隐式包含结尾的`\0`, 且 __实际赋值时，字符串字面量为其字符串所在内存的开始地址.__

由空白(空格、换行、制表符)分隔的字符串字面量将被编译器自动拼接。

---

### 数组初始化

```CPP 
int a[100] = {0};                  		// 每一个元素都被设置成0
int a[100] = {1997,7,26};          		// 除前三个元素为 1997,7,26, 其余均为0
int a[] = {1997,7,26};					// 只开辟三个int型连续内存空间，分别存放1997,7,26.

// C++11:
double a[3] {1.2e4, 3.14, 1.8e-6};		// C++ 11 后可省略 等号
```
只有再申明时才能使用上述初始化方法。 只对一部分元素初始化，则编译器会自动将其余部分置为0.

### C-style 字符串

```CPP
char str[] = {'H','e','l','l','o','\0'};   	// 字符串
char array_char[] = {'H','e','l','l','o'};  // 字符数组，不是字符串!!
```
__C 风格字符串有特殊性质：以空字符(`\0`)结尾，其ASCII码为0.__

### C++ cin 对象成员函数 get/getline
```CPP
// getline() sample:
{
	const int ArSize = 20;
	char name[ArSize];
	cin.getline (name,ArSize);
}

// get() sample:
{
	const int ArSize = 20;
	char FirstName[ArSize];
	char LastName[ArSize];
	cin.get(FirstName,ArSize);
	cin.get();  // cin.get() 默认不读取换行符，因此需要再读取一个。同时此处涉及函数重载，cin对象的成员函数根据参数的不同分别调用读取字符串和读取字符两个不同的函数。
	// 这种方法也可以： cin.get(FirstName,ArSize).get()
	cin.get(LastName,ArSize);
}
```
get 和 getline 与 cin 不同。 cin读取时遇到 空白(空格、换行、制表符) 即判定读取结束，而`get` 和 `getline` 仅识别换行符作为结束，`getline` 丢弃换行符，而 `get` 不丢弃。

### C++ string class
``` CPP
std::string std_str;  // string 类位于 名称空间 std 中。

using namespace std;
string str1 = "Hello World";
string str2;
cin >> str2; //  自动处理 string 的大小,程序会自动调整长度。
cout << str1[0] << endl; 

string str3 = str1 + str1;  // 重载了运算符，可以简单相加来实现 字符串连接
str3 += str1;
```

* __string 类位于 名称空间 std 中__
* __可使用数组表示法来访问string对象中的字符__
* __string 的变量是一个对象__ 
* __与数组不同，可以将一个string对象赋给另一个string对象__
* __重载了运算符，可以简单相加来实现 字符串连接__
* __string 类可以理解成一种动态数组__

---

``` CPP 
int len1 = str1.size();
int len2 = strlen(str1);
```
两种方法都可以获得长度

---

``` CPP 
getline(cin, str1); 
```
string 对象想要读取一行，不能使用 cin 的成员函数 `getline()` ，而使用 istream 引入的函数 `getline()`, `getline(cin, str1);`会指代该函数以 `cin` 作为输入流读取 str1;

### 结构 struct
```CPP 
struct st_var
{
	int key;
	std::string value; // 注意名称空间
};

// C++ 申明结构变量时可以省略 struct
st_var kv_1;
struct st_var kv_1;
```
* __C++ 申明结构变量时可以省略 struct, 而C 不会__
* __其初始化方式等与C基本相同__
* __同类型的结构间可以使用赋值符号来实现拷贝变量内存空间中的值__
* __C++ 中，结构体可以包含成员函数！！！！！__

### 共用体 union / 枚举 enum
```CPP 
enum var 
{
	zero, null = 0,              // zero, null 都为0
	one, first =1				 // one, first 都为1
};
```
union 与 C 基本一样，常用为 __匿名共用体或者匿名结构直接互相嵌套__
enum 与 C 基本一样， 默认首元素为0。 __C++ 中可以创建多个值相同的枚举量!__

### 指针

__OOP(面向对象) 中提倡在运行阶段进行决策而不是编译阶段。e.g. 运行阶段确定数组的长度： 使用关键字new 请求正确数量的内存并使用指针定位__
__指针与数组的结合及运算关系与C一样，较复杂，可看 C-Primer 笔记__

```CPP 
int *p1, p2;					// p1 为指向int的指针类型， p2 为int 类型
int *p1, *p2;					// p1 p2 都为指针类型

p1 = 0x80000000; 				// C++ 中错误！！！
p1 = (int*)0x80000000;			// 正确方式

// 顺序简单记录，详细看 C-primer
short (*p)[20]; 				// 由于括号，* 运算符先作用于 符号p, 表明 p 是一个指针，然后继续，该指针指向一个存放 20 个short的数组。 p++ 将直接将地址加20个字节！
short *p[20];					// [] 优先级高于 *,  [20] 作用于 符号p, 表明 p 是含有20个元素的数组，该数组存放的是short * 类型的指针变量，此时连续开辟20个指针变量！
```
与 C 一样， __使用 指针指向的空间前，一定要确保指针指向某个合理的地址！！！！__

``` CPP
// 如下代码严重错误！！！！！！！！！！！！！！！！！！！！
int * p1;						// p1 没有指向任何内存空间
*p1 = 233333;
```

### new
```CPP 
int *p1 = new int;
delete p1;  					// 该语句只会释放new 分配的对应空间，并不会删除指针本身！ 可以重新指向其他内存块！
```
<font color="red" size="4">
通用格式如下:
typeName * pointer_name = new typeName;

__常规局部变量存储在 栈区(stack).__
__而new 从堆(heap) 或 自由存储区(free store) 的内存区中 分配内存.__
</font>

#### 使用new 创建动态数组

__在运行阶段如果需要数组则创建；否则不创建。且运行时再选择数组的长度，这被称为动态联编(dynamic binding)，数组被称为动态数组(dynamic array)__

```CPP 
int * psome = new int [n];       // 主要格式！！！
delete [] psome;
```

#### delete

delete 会释放new 分配的对应空间，并不会删除指针本身！ 指针可以重新指向其他内存块！
理论上，只能用delete释放使用new分配的内存，但 空指针参数对于delete 也是安全的;

* __delete 只能释放 new分配的内存__
* __delete 释放同一个内存块两次，将导致不确定结果！__
* __`[]` 对于new 和 delete 需要严格对应出现__

```CPP
//合法， 但不推荐！！
int * p1 = new int;
int * p2 = p1;
delete p2;
```
<font color="red">
一般来说，不创建两个指向同一个堆(heap) 或 自由存储区(free store) 内存块的指针，这将增加删除同一个内存块两次的可能性。
</font> 

### 内存相关--基础

C++ 有3种管理内存的方法, 自动存储, 动态存储, 静态存储.

1. 自动存储
局部变量, 作用域对应代码块, __通常情况下, 自动存储为栈内存中, 执行代码块时, 其中的变量依次加入到栈中, 离开代码块时, 将按相反顺序释放这些变量。栈中占用的内存大多数情况下都时连续的__

2. 动态存储 
动态存储管理一个内存池, 在C++ 中被称为 自由存储空间 或 堆(heap)。 其数据完全不受程序运行状态的控制, 需要程序员自己进行内存管理, __堆内存中, 申请的空间并不连续！__

3. 静态存储
静态存储在整个程序执行期间都存在。

### STL 模板类 vector
<font color="red" size="4">

* vector 类包含在 名称空间 std 中
* vector 类使用 `new / delete` 管理内存, 但管理内存工作是自动完成的, 可以很好的作为`new` 创建动态数组的替代品
* `vector<typeName> VarName(Num)`
* 对应头文件 `#include <vector>`
* 可使用标准数组表示法访问各个元素! `a[0]`
* 标准数组表示法不检查越界, 可用成员函数`at()` `begin()` `end()` 等访问, 对应效率会下降. `v.at(2) = 1.2;`

</font>

```CPP 
#include <vector>
std::vector<int> v_0; 	// 创建一个 0长度的 vector
int n = 10;
std::vector<int> v(n); 	// 创建一个 10 长度的vector
v[0] = 1; 				// 效率更高，但不安全
v.at(1) = 2;			// 会检查越界等，但效率下降

```
### STL 模板类 array (C++11)
__STL array 类 为 C++11 引入, 与vector 不同, array 类使用 静态内存分配, 数据位于 栈内存中. 效率高于 vector.__
```CPP
#include <array>
std::array<int, 10> a;
std::array<double, 4> b = {1.1, 1.2, 3.14, 4.86};
```

## Chapter 5 循环, 关系表达式

### 递增递减运算符
#### 副作用与顺序点

```CPP 
// 避免下面这种写法！！！！！
y = (4 + x++) + (5 + x++); // C++ 只保证 该语句结束后(顺序点后)， x+=2, 过程中 x 是否变化并不确定！！！
```
副作用指的计算表达式值时, 进行的修改（如存储的值）
__顺序点为 C++11 前的术语, 在每个顺序点进行下一步之前, 会确保所有副作用都已经完成。 上式中 `;` 就是一个顺序点__
__C++ 只保证 递增递减运算符(`++``--`) 在顺序点前后正确, 过程中并不保证！__

#### 优先级
__前缀递增 前缀递减运算符(`++p``--p`) 与 解引用运算符(`*`) 优先级相同, 后缀递增 后缀递减 (`p++` `p--`) 优先级更高__

```CPP 
*++p 					// 从右向左结合, ++ 先运算，指针前进对应大小的1个内存块,  然后解引用取得值
++*p 					// 先解引用取得当前p 的值, 然后 加1 作为表达式返回值
(*p)++					// 先解引用取得当前p 的值, 然后 加1 作为表达式返回值
*p++					// ++ 先运算，但是是后缀，所以表达式返回值为解引用取得值，然后指针前进对应大小的1个内存块,  

```

### 逗号运算符

针对表达式(expression), C++ 允许使用 `,` 运算符 并列多个表达式, 逗号是一个顺序点, 确保并列的表达式从左往右依次产生副作用, 但整体表达式返回最后一个运算的值。
__变量申明中的`,` 并不是逗号运算符, 与分隔表达式完全不同__
__逗号运算符的优先级是所有运算符中最低的__

```CPP 
int a;
a = 1,2; // a 为1, 因为 逗号运算符 优先级低于 赋值运算符, 所以语句被解释成 (a = 1), 2;
a = (1,2); // a 为2
```

### 字符串比较
字典排序: 若两字符串不等, 依次从前往后寻找到第一个对应不相等的字符, 按ASCII 码顺序比较大小, 小的在前,大的在后

#### C-style  strcmp()
```CPP 
strcmp(str1, str2);
```
* 两字符串相等, 返回0; 
* str1 字典排序 在 str2 之前,  返回负数;
* str1 字典排序 在 str2 之后,  返回正数数;

#### string 类
__string 类重载了关系运算符, 可以直接比较。__

### range-based for (C++11)

__主要用于模板类，例如 STL.__

