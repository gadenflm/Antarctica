[TOC]
#动态连通性问题(核心算法：并查集)

## 基础

### 问题描述

给定 n 个节点(nodes) 及 节点两两之间的连接关系(link), 判断任意两点是否连通。

### 个人心得
<font size="4">
并查集算法通过树型结构存储点与点之间的连通性关系，连通的两点必在一个连通分支内。

__判断两点是否同属一个连通分支方法为判断两点的根节点是否相同。算法的时间复杂度消耗集中在回溯寻找任意一个节点的根节点，因此主要优化思路为 保证连通关系不变的同时，将整个树的深度(depth) 压缩！__
</font>

<font color="red" size="4">
算法步骤:  

1. 初始化树形结构，得到 n 个连通分支(此时各点互不相连)。  
2. 依次将连接的两点所在的连通分支合并。  
3. 根据要求判断两点是否同属于一个连通分支。  

__优化(improvements):__  

* __一. 增加点权重(Weight)，用以记录每个节点下子节点数量。使得每次合并连通分支时,总是将较小树作为较大树的孩子节点！这样保证N个节点构成整个树的深度 <= log2(N)。__ 
  
* __二. 在 一 的基础上，每次回溯寻找根节点过程中，引入压缩过程(Link Compression),回溯访问到的每一个孩子节点，都将其和其父节点改为并列关系，即将孩子节点与爷爷节点相连。__

</font>

__时间复杂度分析__

并查集算法的时间复杂度为 `O( n+m·lg*(n) )`, 其中m为两点间存在连接的个数。 而 `lg*(n)` 为一个成长极慢的函数, 有`lg*(2^65536) == 5`。 因为 2^65536 的数量级基本可以概况自然情况下绝大多数问题。 因此可以把 lg*(n) 视为小于5的常数。 又因为通常情况下 `m>>n`, 最终得到正常情况下该算法的时间复杂度为 O(m), 即 连接数个数 线性相关的时间复杂度算法。

__进阶:__

* (TODO) 删除已知连接，即拆分并查集问题。

### 0 Quick_Find

时间复杂度 __O(m·n)__

维护数组`link_arr[node]`,存储值为其连接的点。 `link_arr[node] == node` 时，该点即为根节点。

Quick_Find 思路极其简单，每次连接两点时，遍历整个数组，将与`node_2` 相连的每个节点都改成与 `node_1` 相连。 O(n)

是否相连只需判断 两点相连点是否相同 即可。 O(1)

查找过程很快为O(1)因此称为`Quick_Find`, 实际时间复杂度非常大。

### 1 Quick_Union

时间复杂度 __`O(m·n')`__  
大体上 `log2(n) <= n' <= n` 该算法为不稳定算法，其时间复杂度受连接顺序影响。

__Quick Union 将连接两点过程改为合并对应的连通分支，即将两点所在连通分支的根节点对应相连。__
`link_arr[find_root(node_2)] = link_arr[find_root(node_1)];`

增加过程寻找根节点，即从任一回溯访问其父亲节点直至根节点。`O(n')` (__此过程为主要时间复杂度消耗,具体耗时取决于节点在树中的深度，后面的改进都是基于此压缩节点在树种的深度__)

### 2 Key Improvements: Add Weight(增加权重)

时间复杂度 __`O(m·lg(n))`__

__优化：每次合并连通分支时,总是将较小树作为较大树的孩子节点！这样保证N个节点构成整个树的深度 <= log2(N)__

增加第二个数组，`node_weight[·]` 记录每个节点下，子节点的个数。 合并时判断并对应累加即可。

### 3 并查集算法, Improvements: Link Compression(回溯过程中压缩树的深度)

时间复杂度 __`O(m·lg*(n))`__

__每次回溯寻找根节点过程中，引入压缩过程(Link Compression),回溯访问到的每一个孩子节点，都将其和其父节点改为并列关系，即将孩子节点与爷爷节点相连。__

```C 
// O(lg*(n)), when we find, we can compress the link by the way.
uint32_t find_root (uint32_t node) {
    while (link_arr[node] != node) {
        // link the node to father's father.
        link_arr[node] = link_arr[link_arr[node]];
        node = link_arr[node];
    }
    return node;
}
```

## 做题总结
